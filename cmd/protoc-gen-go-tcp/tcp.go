package main

import (
	"fmt"
	"strconv"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/types/descriptorpb"
)

// generateFile generates a _tcp.pb.go file containing kratos TCP service definitions.
func generateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	if len(file.Services) == 0 {
		return nil
	}
	filename := file.GeneratedFilenamePrefix + "_tcp.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	generateFileHeader(gen, file, g)
	generateImports(gen, file, g)

	for _, service := range file.Services {
		genService(gen, file, g, service)
	}

	return g
}

func generateFileHeader(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile) {
	g.P("// Code generated by protoc-gen-go-tcp. DO NOT EDIT.")
	g.P("// versions:")
	g.P(fmt.Sprintf("// - protoc-gen-go-tcp %s", release))
	g.P("// - protoc            ", protocVersion(gen))
	if file.Proto.GetOptions().GetDeprecated() {
		g.P("// ", file.Desc.Path(), " is a deprecated file.")
	} else {
		g.P("// source: ", file.Desc.Path())
	}
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
}

func generateImports(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile) {
	if len(file.Services) == 0 {
		return
	}
	g.P("// This is a compile-time assertion to ensure that this generated file")
	g.P("// is compatible with the kratos package it is being compiled against.")

	g.P(`import (`)
	g.P(`	"context"`)
	g.P()
	g.P(`	"github.com/yola1107/kratos/v2/library/work"`)
	g.P(`	"github.com/yola1107/kratos/v2/transport/tcp"`)
	g.P()
	g.P(`	"google.golang.org/grpc/codes"`)
	g.P(`	"google.golang.org/grpc/status"`)
	g.P(`	"google.golang.org/protobuf/proto"`)
	g.P(`)`)
	g.P()
}

// 生成 TCP 服务器端代码
func genService(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, service *protogen.Service) {
	// 检查服务是否被标记为已弃用
	if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
		g.P("//")
		g.P(deprecationComment)
	}

	var (
		serviceName    = service.GoName
		serviceDescVar = fmt.Sprintf("%s_TCP_ServiceDesc", serviceName)
		fullServName   = fmt.Sprintf("%s.%s", file.Desc.Package(), serviceName)
	)

	// 生成 TCP 服务器接口
	generateTCPInterface(g, serviceName, service)

	// 生成 TCP 服务器注册代码
	g.P("func Register", serviceName, "TCPServer(s *tcp.Server, srv ", serviceName, "TCPServer) {")
	g.P(`	chanList := s.RegisterService(&`, serviceDescVar, `, srv)`)
	g.P("	srv.SetCometChan(chanList, s)")
	g.P("}")
	g.P()

	// 生成 TCP 服务器处理函数
	var handlerNames []string
	for _, method := range service.Methods {
		hname := generateServerMethod(g, serviceName, fullServName, method)
		handlerNames = append(handlerNames, hname)
	}

	// 生成 TCP 服务器处理函数的Ops (请求协议code)
	gameCommand := make(map[string]string)
	for _, enum := range file.Enums {
		if enum.Desc.Name() != "GameCommand" {
			continue
		}
		for _, v := range enum.Values {
			gameCommand[string(v.Desc.Name())] = fmt.Sprintf("%d", v.Desc.Number())
		}
	}

	// 生成Service descriptor
	g.P(`var `, serviceDescVar, ` = tcp.ServiceDesc{`)
	g.P(`	ServiceName: `, strconv.Quote(fullServName), `,`)
	g.P(`	HandlerType: (*`, serviceName, `TCPServer)(nil),`)
	g.P(`	Methods: []tcp.MethodDesc{`)
	for i, method := range service.Methods {
		g.P(`		{`)
		g.P(`			MethodName: `, strconv.Quote(method.GoName), `,`)
		g.P(`			Handler: `, handlerNames[i], `,`)
		g.P(`			Ops: `, gameCommand[method.GoName], `,`)
		g.P(`		},`)
	}
	g.P(`	},`)
	g.P(`}`)
}

// 生成TCP服务接口
func generateTCPInterface(g *protogen.GeneratedFile, serviceName string, service *protogen.Service) {
	g.P("// ", serviceName, "TCPServer is the server API for ", serviceName, " service.")
	g.P("type ", serviceName, "TCPServer interface {")
	g.P(`	GetTCPLoop() work.Loop`)
	g.P(`	SetCometChan(cl *tcp.ChanList, cs *tcp.Server)`)

	for _, method := range service.Methods {
		if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
			continue
		}
		g.P("	", method.GoName, "(context.Context, *", method.Input.GoIdent, ") (*", method.Output.GoIdent, ", error)")
	}
	g.P(`}`)
	g.P()
}

// 生成服务器方法处理函数
func generateServerMethod(g *protogen.GeneratedFile, servName, fullServName string, method *protogen.Method) string {
	methName := method.GoName
	hname := fmt.Sprintf("_%s_%s_TCP_Handler", servName, methName)
	inputType := method.Input.Desc.Name()

	g.P(`func `, hname, `(srv interface{}, ctx context.Context, data []byte, interceptor tcp.UnaryServerInterceptor) ([]byte, error) {`)
	g.P(`	in := new(`, inputType, `)`)
	g.P(`	if err := proto.Unmarshal(data, in); err != nil {`)
	g.P(`		return nil, err`)
	g.P(`	}`)
	// g.P()

	// 核心处理逻辑
	g.P(`	doFunc := func(ctx context.Context, req *`, inputType, `) ([]byte, error) {`)
	g.P(`		doRequest := func() ([]byte, error) {`)
	g.P(`			resp, err := srv.(`, servName, `TCPServer).`, methName, `(ctx, req)`)
	g.P(`			if err != nil || resp == nil {`)
	g.P(`				return nil, err`)
	g.P(`			}`)
	g.P(`			return proto.Marshal(resp)`)
	g.P(`		}`)
	// g.P()
	g.P(`		if loop := srv.(`, servName, `TCPServer).GetTCPLoop(); loop != nil {`)
	g.P(`			return loop.PostAndWaitCtx(ctx, doRequest)`)
	g.P(`		}`)
	g.P(`		return doRequest()`)
	g.P(`	}`)
	// g.P()

	// 无拦截器时直接处理
	g.P(`	if interceptor == nil {`)
	g.P(`		return doFunc(ctx, in)`)
	g.P(`	}`)
	// g.P()

	// 配置拦截器信息
	g.P(`	info := &tcp.UnaryServerInfo{`)
	g.P(`		Server:     srv,`)
	g.P(`		FullMethod: `, strconv.Quote(fmt.Sprintf("/%s/%s", fullServName, methName)), `,`)
	g.P(`	}`)
	// g.P()

	// 拦截器处理函数
	g.P(`	handler := func(ctx context.Context, req interface{}) ([]byte, error) {`)
	g.P(`		r, ok := req.(*`, inputType, `)`)
	g.P(`		if !ok {`)
	g.P(`			return nil, status.Errorf(codes.InvalidArgument, "Invalid Request Argument, expect: *`, inputType, `, Not: %T", req)`)
	g.P(`		}`)
	g.P(`		return doFunc(ctx, r)`)
	g.P(`	}`)
	// g.P()

	g.P(`	return interceptor(ctx, in, info, handler)`)
	g.P(`}`)
	g.P()

	return hname
}

func protocVersion(gen *protogen.Plugin) string {
	v := gen.Request.GetCompilerVersion()
	if v == nil {
		return "(unknown)"
	}
	var suffix string
	if s := v.GetSuffix(); s != "" {
		suffix = "-" + s
	}
	return fmt.Sprintf("v%d.%d.%d%s", v.GetMajor(), v.GetMinor(), v.GetPatch(), suffix)
}

const deprecationComment = "// Deprecated: Do not use."
