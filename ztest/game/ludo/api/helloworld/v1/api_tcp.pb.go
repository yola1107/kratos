// Code generated by protoc-gen-go-tcp. DO NOT EDIT.
// versions:
// - protoc-gen-go-tcp v2.8.6
// - protoc            v3.6.1
// source: helloworld/v1/api.proto

package v1

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
import (
	"context"

	"github.com/yola1107/kratos/v2/library/work"
	"github.com/yola1107/kratos/v2/transport/tcp"

	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/proto"
)

// LudoTCPServer is the server API for Ludo service.
type LudoTCPServer interface {
	GetTCPLoop() work.ITaskLoop
	SetCometChan(cl *tcp.ChanList, cs *tcp.Server)
	SayHelloReq(context.Context, *HelloRequest) (*HelloReply, error)
	OnLoginReq(context.Context, *LoginReq) (*LoginRsp, error)
	OnLogoutReq(context.Context, *LogoutReq) (*LogoutRsp, error)
	OnReadyReq(context.Context, *ReadyReq) (*ReadyRsp, error)
	OnSwitchTableReq(context.Context, *SwitchTableReq) (*SwitchTableRsp, error)
	OnSceneReq(context.Context, *SceneReq) (*SceneRsp, error)
	OnChatReq(context.Context, *ChatReq) (*ChatRsp, error)
	OnHostingReq(context.Context, *HostingReq) (*HostingRsp, error)
	OnForwardReq(context.Context, *ForwardReq) (*ForwardRsp, error)
	OnMoveReq(context.Context, *MoveReq) (*MoveRsp, error)
	OnDiceReq(context.Context, *DiceReq) (*DiceRsp, error)
}

func RegisterLudoTCPServer(s *tcp.Server, srv LudoTCPServer) {
	chanList := s.RegisterService(&Ludo_TCP_ServiceDesc, srv)
	srv.SetCometChan(chanList, s)
}

func _Ludo_SayHelloReq_TCP_Handler(srv interface{}, ctx context.Context, data []byte, interceptor tcp.UnaryServerInterceptor) ([]byte, error) {
	in := new(HelloRequest)
	if err := proto.Unmarshal(data, in); err != nil {
		return nil, err
	}
	doFunc := func(ctx context.Context, req *HelloRequest) ([]byte, error) {
		doRequest := func() ([]byte, error) {
			resp, err := srv.(LudoTCPServer).SayHelloReq(ctx, req)
			if err != nil || resp == nil {
				return nil, err
			}
			return proto.Marshal(resp)
		}
		if loop := srv.(LudoTCPServer).GetTCPLoop(); loop != nil {
			return loop.PostAndWaitCtx(ctx, doRequest)
		}
		return doRequest()
	}
	if interceptor == nil {
		return doFunc(ctx, in)
	}
	info := &tcp.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ludo.v1.Ludo/SayHelloReq",
	}
	handler := func(ctx context.Context, req interface{}) ([]byte, error) {
		r, ok := req.(*HelloRequest)
		if !ok {
			return nil, status.Errorf(codes.InvalidArgument, "Invalid Request Argument, expect: *HelloRequest, Not: %T", req)
		}
		return doFunc(ctx, r)
	}
	return interceptor(ctx, in, info, handler)
}

func _Ludo_OnLoginReq_TCP_Handler(srv interface{}, ctx context.Context, data []byte, interceptor tcp.UnaryServerInterceptor) ([]byte, error) {
	in := new(LoginReq)
	if err := proto.Unmarshal(data, in); err != nil {
		return nil, err
	}
	doFunc := func(ctx context.Context, req *LoginReq) ([]byte, error) {
		doRequest := func() ([]byte, error) {
			resp, err := srv.(LudoTCPServer).OnLoginReq(ctx, req)
			if err != nil || resp == nil {
				return nil, err
			}
			return proto.Marshal(resp)
		}
		if loop := srv.(LudoTCPServer).GetTCPLoop(); loop != nil {
			return loop.PostAndWaitCtx(ctx, doRequest)
		}
		return doRequest()
	}
	if interceptor == nil {
		return doFunc(ctx, in)
	}
	info := &tcp.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ludo.v1.Ludo/OnLoginReq",
	}
	handler := func(ctx context.Context, req interface{}) ([]byte, error) {
		r, ok := req.(*LoginReq)
		if !ok {
			return nil, status.Errorf(codes.InvalidArgument, "Invalid Request Argument, expect: *LoginReq, Not: %T", req)
		}
		return doFunc(ctx, r)
	}
	return interceptor(ctx, in, info, handler)
}

func _Ludo_OnLogoutReq_TCP_Handler(srv interface{}, ctx context.Context, data []byte, interceptor tcp.UnaryServerInterceptor) ([]byte, error) {
	in := new(LogoutReq)
	if err := proto.Unmarshal(data, in); err != nil {
		return nil, err
	}
	doFunc := func(ctx context.Context, req *LogoutReq) ([]byte, error) {
		doRequest := func() ([]byte, error) {
			resp, err := srv.(LudoTCPServer).OnLogoutReq(ctx, req)
			if err != nil || resp == nil {
				return nil, err
			}
			return proto.Marshal(resp)
		}
		if loop := srv.(LudoTCPServer).GetTCPLoop(); loop != nil {
			return loop.PostAndWaitCtx(ctx, doRequest)
		}
		return doRequest()
	}
	if interceptor == nil {
		return doFunc(ctx, in)
	}
	info := &tcp.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ludo.v1.Ludo/OnLogoutReq",
	}
	handler := func(ctx context.Context, req interface{}) ([]byte, error) {
		r, ok := req.(*LogoutReq)
		if !ok {
			return nil, status.Errorf(codes.InvalidArgument, "Invalid Request Argument, expect: *LogoutReq, Not: %T", req)
		}
		return doFunc(ctx, r)
	}
	return interceptor(ctx, in, info, handler)
}

func _Ludo_OnReadyReq_TCP_Handler(srv interface{}, ctx context.Context, data []byte, interceptor tcp.UnaryServerInterceptor) ([]byte, error) {
	in := new(ReadyReq)
	if err := proto.Unmarshal(data, in); err != nil {
		return nil, err
	}
	doFunc := func(ctx context.Context, req *ReadyReq) ([]byte, error) {
		doRequest := func() ([]byte, error) {
			resp, err := srv.(LudoTCPServer).OnReadyReq(ctx, req)
			if err != nil || resp == nil {
				return nil, err
			}
			return proto.Marshal(resp)
		}
		if loop := srv.(LudoTCPServer).GetTCPLoop(); loop != nil {
			return loop.PostAndWaitCtx(ctx, doRequest)
		}
		return doRequest()
	}
	if interceptor == nil {
		return doFunc(ctx, in)
	}
	info := &tcp.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ludo.v1.Ludo/OnReadyReq",
	}
	handler := func(ctx context.Context, req interface{}) ([]byte, error) {
		r, ok := req.(*ReadyReq)
		if !ok {
			return nil, status.Errorf(codes.InvalidArgument, "Invalid Request Argument, expect: *ReadyReq, Not: %T", req)
		}
		return doFunc(ctx, r)
	}
	return interceptor(ctx, in, info, handler)
}

func _Ludo_OnSwitchTableReq_TCP_Handler(srv interface{}, ctx context.Context, data []byte, interceptor tcp.UnaryServerInterceptor) ([]byte, error) {
	in := new(SwitchTableReq)
	if err := proto.Unmarshal(data, in); err != nil {
		return nil, err
	}
	doFunc := func(ctx context.Context, req *SwitchTableReq) ([]byte, error) {
		doRequest := func() ([]byte, error) {
			resp, err := srv.(LudoTCPServer).OnSwitchTableReq(ctx, req)
			if err != nil || resp == nil {
				return nil, err
			}
			return proto.Marshal(resp)
		}
		if loop := srv.(LudoTCPServer).GetTCPLoop(); loop != nil {
			return loop.PostAndWaitCtx(ctx, doRequest)
		}
		return doRequest()
	}
	if interceptor == nil {
		return doFunc(ctx, in)
	}
	info := &tcp.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ludo.v1.Ludo/OnSwitchTableReq",
	}
	handler := func(ctx context.Context, req interface{}) ([]byte, error) {
		r, ok := req.(*SwitchTableReq)
		if !ok {
			return nil, status.Errorf(codes.InvalidArgument, "Invalid Request Argument, expect: *SwitchTableReq, Not: %T", req)
		}
		return doFunc(ctx, r)
	}
	return interceptor(ctx, in, info, handler)
}

func _Ludo_OnSceneReq_TCP_Handler(srv interface{}, ctx context.Context, data []byte, interceptor tcp.UnaryServerInterceptor) ([]byte, error) {
	in := new(SceneReq)
	if err := proto.Unmarshal(data, in); err != nil {
		return nil, err
	}
	doFunc := func(ctx context.Context, req *SceneReq) ([]byte, error) {
		doRequest := func() ([]byte, error) {
			resp, err := srv.(LudoTCPServer).OnSceneReq(ctx, req)
			if err != nil || resp == nil {
				return nil, err
			}
			return proto.Marshal(resp)
		}
		if loop := srv.(LudoTCPServer).GetTCPLoop(); loop != nil {
			return loop.PostAndWaitCtx(ctx, doRequest)
		}
		return doRequest()
	}
	if interceptor == nil {
		return doFunc(ctx, in)
	}
	info := &tcp.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ludo.v1.Ludo/OnSceneReq",
	}
	handler := func(ctx context.Context, req interface{}) ([]byte, error) {
		r, ok := req.(*SceneReq)
		if !ok {
			return nil, status.Errorf(codes.InvalidArgument, "Invalid Request Argument, expect: *SceneReq, Not: %T", req)
		}
		return doFunc(ctx, r)
	}
	return interceptor(ctx, in, info, handler)
}

func _Ludo_OnChatReq_TCP_Handler(srv interface{}, ctx context.Context, data []byte, interceptor tcp.UnaryServerInterceptor) ([]byte, error) {
	in := new(ChatReq)
	if err := proto.Unmarshal(data, in); err != nil {
		return nil, err
	}
	doFunc := func(ctx context.Context, req *ChatReq) ([]byte, error) {
		doRequest := func() ([]byte, error) {
			resp, err := srv.(LudoTCPServer).OnChatReq(ctx, req)
			if err != nil || resp == nil {
				return nil, err
			}
			return proto.Marshal(resp)
		}
		if loop := srv.(LudoTCPServer).GetTCPLoop(); loop != nil {
			return loop.PostAndWaitCtx(ctx, doRequest)
		}
		return doRequest()
	}
	if interceptor == nil {
		return doFunc(ctx, in)
	}
	info := &tcp.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ludo.v1.Ludo/OnChatReq",
	}
	handler := func(ctx context.Context, req interface{}) ([]byte, error) {
		r, ok := req.(*ChatReq)
		if !ok {
			return nil, status.Errorf(codes.InvalidArgument, "Invalid Request Argument, expect: *ChatReq, Not: %T", req)
		}
		return doFunc(ctx, r)
	}
	return interceptor(ctx, in, info, handler)
}

func _Ludo_OnHostingReq_TCP_Handler(srv interface{}, ctx context.Context, data []byte, interceptor tcp.UnaryServerInterceptor) ([]byte, error) {
	in := new(HostingReq)
	if err := proto.Unmarshal(data, in); err != nil {
		return nil, err
	}
	doFunc := func(ctx context.Context, req *HostingReq) ([]byte, error) {
		doRequest := func() ([]byte, error) {
			resp, err := srv.(LudoTCPServer).OnHostingReq(ctx, req)
			if err != nil || resp == nil {
				return nil, err
			}
			return proto.Marshal(resp)
		}
		if loop := srv.(LudoTCPServer).GetTCPLoop(); loop != nil {
			return loop.PostAndWaitCtx(ctx, doRequest)
		}
		return doRequest()
	}
	if interceptor == nil {
		return doFunc(ctx, in)
	}
	info := &tcp.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ludo.v1.Ludo/OnHostingReq",
	}
	handler := func(ctx context.Context, req interface{}) ([]byte, error) {
		r, ok := req.(*HostingReq)
		if !ok {
			return nil, status.Errorf(codes.InvalidArgument, "Invalid Request Argument, expect: *HostingReq, Not: %T", req)
		}
		return doFunc(ctx, r)
	}
	return interceptor(ctx, in, info, handler)
}

func _Ludo_OnForwardReq_TCP_Handler(srv interface{}, ctx context.Context, data []byte, interceptor tcp.UnaryServerInterceptor) ([]byte, error) {
	in := new(ForwardReq)
	if err := proto.Unmarshal(data, in); err != nil {
		return nil, err
	}
	doFunc := func(ctx context.Context, req *ForwardReq) ([]byte, error) {
		doRequest := func() ([]byte, error) {
			resp, err := srv.(LudoTCPServer).OnForwardReq(ctx, req)
			if err != nil || resp == nil {
				return nil, err
			}
			return proto.Marshal(resp)
		}
		if loop := srv.(LudoTCPServer).GetTCPLoop(); loop != nil {
			return loop.PostAndWaitCtx(ctx, doRequest)
		}
		return doRequest()
	}
	if interceptor == nil {
		return doFunc(ctx, in)
	}
	info := &tcp.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ludo.v1.Ludo/OnForwardReq",
	}
	handler := func(ctx context.Context, req interface{}) ([]byte, error) {
		r, ok := req.(*ForwardReq)
		if !ok {
			return nil, status.Errorf(codes.InvalidArgument, "Invalid Request Argument, expect: *ForwardReq, Not: %T", req)
		}
		return doFunc(ctx, r)
	}
	return interceptor(ctx, in, info, handler)
}

func _Ludo_OnMoveReq_TCP_Handler(srv interface{}, ctx context.Context, data []byte, interceptor tcp.UnaryServerInterceptor) ([]byte, error) {
	in := new(MoveReq)
	if err := proto.Unmarshal(data, in); err != nil {
		return nil, err
	}
	doFunc := func(ctx context.Context, req *MoveReq) ([]byte, error) {
		doRequest := func() ([]byte, error) {
			resp, err := srv.(LudoTCPServer).OnMoveReq(ctx, req)
			if err != nil || resp == nil {
				return nil, err
			}
			return proto.Marshal(resp)
		}
		if loop := srv.(LudoTCPServer).GetTCPLoop(); loop != nil {
			return loop.PostAndWaitCtx(ctx, doRequest)
		}
		return doRequest()
	}
	if interceptor == nil {
		return doFunc(ctx, in)
	}
	info := &tcp.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ludo.v1.Ludo/OnMoveReq",
	}
	handler := func(ctx context.Context, req interface{}) ([]byte, error) {
		r, ok := req.(*MoveReq)
		if !ok {
			return nil, status.Errorf(codes.InvalidArgument, "Invalid Request Argument, expect: *MoveReq, Not: %T", req)
		}
		return doFunc(ctx, r)
	}
	return interceptor(ctx, in, info, handler)
}

func _Ludo_OnDiceReq_TCP_Handler(srv interface{}, ctx context.Context, data []byte, interceptor tcp.UnaryServerInterceptor) ([]byte, error) {
	in := new(DiceReq)
	if err := proto.Unmarshal(data, in); err != nil {
		return nil, err
	}
	doFunc := func(ctx context.Context, req *DiceReq) ([]byte, error) {
		doRequest := func() ([]byte, error) {
			resp, err := srv.(LudoTCPServer).OnDiceReq(ctx, req)
			if err != nil || resp == nil {
				return nil, err
			}
			return proto.Marshal(resp)
		}
		if loop := srv.(LudoTCPServer).GetTCPLoop(); loop != nil {
			return loop.PostAndWaitCtx(ctx, doRequest)
		}
		return doRequest()
	}
	if interceptor == nil {
		return doFunc(ctx, in)
	}
	info := &tcp.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ludo.v1.Ludo/OnDiceReq",
	}
	handler := func(ctx context.Context, req interface{}) ([]byte, error) {
		r, ok := req.(*DiceReq)
		if !ok {
			return nil, status.Errorf(codes.InvalidArgument, "Invalid Request Argument, expect: *DiceReq, Not: %T", req)
		}
		return doFunc(ctx, r)
	}
	return interceptor(ctx, in, info, handler)
}

var Ludo_TCP_ServiceDesc = tcp.ServiceDesc{
	ServiceName: "ludo.v1.Ludo",
	HandlerType: (*LudoTCPServer)(nil),
	Methods: []tcp.MethodDesc{
		{
			MethodName: "SayHelloReq",
			Handler:    _Ludo_SayHelloReq_TCP_Handler,
			Ops:        1,
		},
		{
			MethodName: "OnLoginReq",
			Handler:    _Ludo_OnLoginReq_TCP_Handler,
			Ops:        1001,
		},
		{
			MethodName: "OnLogoutReq",
			Handler:    _Ludo_OnLogoutReq_TCP_Handler,
			Ops:        1003,
		},
		{
			MethodName: "OnReadyReq",
			Handler:    _Ludo_OnReadyReq_TCP_Handler,
			Ops:        1005,
		},
		{
			MethodName: "OnSwitchTableReq",
			Handler:    _Ludo_OnSwitchTableReq_TCP_Handler,
			Ops:        1007,
		},
		{
			MethodName: "OnSceneReq",
			Handler:    _Ludo_OnSceneReq_TCP_Handler,
			Ops:        1009,
		},
		{
			MethodName: "OnChatReq",
			Handler:    _Ludo_OnChatReq_TCP_Handler,
			Ops:        1011,
		},
		{
			MethodName: "OnHostingReq",
			Handler:    _Ludo_OnHostingReq_TCP_Handler,
			Ops:        1013,
		},
		{
			MethodName: "OnForwardReq",
			Handler:    _Ludo_OnForwardReq_TCP_Handler,
			Ops:        1015,
		},
		{
			MethodName: "OnMoveReq",
			Handler:    _Ludo_OnMoveReq_TCP_Handler,
			Ops:        1101,
		},
		{
			MethodName: "OnDiceReq",
			Handler:    _Ludo_OnDiceReq_TCP_Handler,
			Ops:        1103,
		},
	},
}
