// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.8.6
// - protoc             v3.6.1
// source: helloworld/v1/api.proto

package v1

import (
	context "context"
	http "github.com/yola1107/kratos/v2/transport/http"
	binding "github.com/yola1107/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationLudoOnChatReq = "/ludo.v1.Ludo/OnChatReq"
const OperationLudoOnDiceReq = "/ludo.v1.Ludo/OnDiceReq"
const OperationLudoOnForwardReq = "/ludo.v1.Ludo/OnForwardReq"
const OperationLudoOnHostingReq = "/ludo.v1.Ludo/OnHostingReq"
const OperationLudoOnLoginReq = "/ludo.v1.Ludo/OnLoginReq"
const OperationLudoOnLogoutReq = "/ludo.v1.Ludo/OnLogoutReq"
const OperationLudoOnMoveReq = "/ludo.v1.Ludo/OnMoveReq"
const OperationLudoOnReadyReq = "/ludo.v1.Ludo/OnReadyReq"
const OperationLudoOnSceneReq = "/ludo.v1.Ludo/OnSceneReq"
const OperationLudoOnSwitchTableReq = "/ludo.v1.Ludo/OnSwitchTableReq"
const OperationLudoSayHelloReq = "/ludo.v1.Ludo/SayHelloReq"

type LudoHTTPServer interface {
	OnChatReq(context.Context, *ChatReq) (*ChatRsp, error)
	OnDiceReq(context.Context, *DiceReq) (*DiceRsp, error)
	OnForwardReq(context.Context, *ForwardReq) (*ForwardRsp, error)
	OnHostingReq(context.Context, *HostingReq) (*HostingRsp, error)
	OnLoginReq(context.Context, *LoginReq) (*LoginRsp, error)
	OnLogoutReq(context.Context, *LogoutReq) (*LogoutRsp, error)
	// OnMoveReqgame request
	OnMoveReq(context.Context, *MoveReq) (*MoveRsp, error)
	OnReadyReq(context.Context, *ReadyReq) (*ReadyRsp, error)
	OnSceneReq(context.Context, *SceneReq) (*SceneRsp, error)
	OnSwitchTableReq(context.Context, *SwitchTableReq) (*SwitchTableRsp, error)
	// SayHelloReqSends a greeting
	SayHelloReq(context.Context, *HelloRequest) (*HelloReply, error)
}

func RegisterLudoHTTPServer(s *http.Server, srv LudoHTTPServer) {
	r := s.Route("/")
	r.GET("/ludo/{name}", _Ludo_SayHelloReq0_HTTP_Handler(srv))
	r.POST("/ludo/OnLoginReq", _Ludo_OnLoginReq0_HTTP_Handler(srv))
	r.POST("/ludo/OnLogoutReq", _Ludo_OnLogoutReq0_HTTP_Handler(srv))
	r.POST("/ludo/OnReadyReq", _Ludo_OnReadyReq0_HTTP_Handler(srv))
	r.POST("/ludo/OnSwitchTableReq", _Ludo_OnSwitchTableReq0_HTTP_Handler(srv))
	r.POST("/ludo/OnSceneReq", _Ludo_OnSceneReq0_HTTP_Handler(srv))
	r.POST("/ludo/OnChatOrFaceReq", _Ludo_OnChatReq0_HTTP_Handler(srv))
	r.POST("/ludo/OnHostingReq", _Ludo_OnHostingReq0_HTTP_Handler(srv))
	r.POST("/ludo/OnForwardReq", _Ludo_OnForwardReq0_HTTP_Handler(srv))
	r.POST("/ludo/OnMoveReq", _Ludo_OnMoveReq0_HTTP_Handler(srv))
	r.POST("/ludo/OnDiceReq", _Ludo_OnDiceReq0_HTTP_Handler(srv))
}

func _Ludo_SayHelloReq0_HTTP_Handler(srv LudoHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in HelloRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationLudoSayHelloReq)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.SayHelloReq(ctx, req.(*HelloRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*HelloReply)
		return ctx.Result(200, reply)
	}
}

func _Ludo_OnLoginReq0_HTTP_Handler(srv LudoHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in LoginReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationLudoOnLoginReq)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.OnLoginReq(ctx, req.(*LoginReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*LoginRsp)
		return ctx.Result(200, reply)
	}
}

func _Ludo_OnLogoutReq0_HTTP_Handler(srv LudoHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in LogoutReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationLudoOnLogoutReq)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.OnLogoutReq(ctx, req.(*LogoutReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*LogoutRsp)
		return ctx.Result(200, reply)
	}
}

func _Ludo_OnReadyReq0_HTTP_Handler(srv LudoHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ReadyReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationLudoOnReadyReq)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.OnReadyReq(ctx, req.(*ReadyReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ReadyRsp)
		return ctx.Result(200, reply)
	}
}

func _Ludo_OnSwitchTableReq0_HTTP_Handler(srv LudoHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in SwitchTableReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationLudoOnSwitchTableReq)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.OnSwitchTableReq(ctx, req.(*SwitchTableReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*SwitchTableRsp)
		return ctx.Result(200, reply)
	}
}

func _Ludo_OnSceneReq0_HTTP_Handler(srv LudoHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in SceneReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationLudoOnSceneReq)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.OnSceneReq(ctx, req.(*SceneReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*SceneRsp)
		return ctx.Result(200, reply)
	}
}

func _Ludo_OnChatReq0_HTTP_Handler(srv LudoHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ChatReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationLudoOnChatReq)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.OnChatReq(ctx, req.(*ChatReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ChatRsp)
		return ctx.Result(200, reply)
	}
}

func _Ludo_OnHostingReq0_HTTP_Handler(srv LudoHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in HostingReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationLudoOnHostingReq)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.OnHostingReq(ctx, req.(*HostingReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*HostingRsp)
		return ctx.Result(200, reply)
	}
}

func _Ludo_OnForwardReq0_HTTP_Handler(srv LudoHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ForwardReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationLudoOnForwardReq)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.OnForwardReq(ctx, req.(*ForwardReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ForwardRsp)
		return ctx.Result(200, reply)
	}
}

func _Ludo_OnMoveReq0_HTTP_Handler(srv LudoHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in MoveReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationLudoOnMoveReq)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.OnMoveReq(ctx, req.(*MoveReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*MoveRsp)
		return ctx.Result(200, reply)
	}
}

func _Ludo_OnDiceReq0_HTTP_Handler(srv LudoHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DiceReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationLudoOnDiceReq)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.OnDiceReq(ctx, req.(*DiceReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*DiceRsp)
		return ctx.Result(200, reply)
	}
}

type LudoHTTPClient interface {
	OnChatReq(ctx context.Context, req *ChatReq, opts ...http.CallOption) (rsp *ChatRsp, err error)
	OnDiceReq(ctx context.Context, req *DiceReq, opts ...http.CallOption) (rsp *DiceRsp, err error)
	OnForwardReq(ctx context.Context, req *ForwardReq, opts ...http.CallOption) (rsp *ForwardRsp, err error)
	OnHostingReq(ctx context.Context, req *HostingReq, opts ...http.CallOption) (rsp *HostingRsp, err error)
	OnLoginReq(ctx context.Context, req *LoginReq, opts ...http.CallOption) (rsp *LoginRsp, err error)
	OnLogoutReq(ctx context.Context, req *LogoutReq, opts ...http.CallOption) (rsp *LogoutRsp, err error)
	OnMoveReq(ctx context.Context, req *MoveReq, opts ...http.CallOption) (rsp *MoveRsp, err error)
	OnReadyReq(ctx context.Context, req *ReadyReq, opts ...http.CallOption) (rsp *ReadyRsp, err error)
	OnSceneReq(ctx context.Context, req *SceneReq, opts ...http.CallOption) (rsp *SceneRsp, err error)
	OnSwitchTableReq(ctx context.Context, req *SwitchTableReq, opts ...http.CallOption) (rsp *SwitchTableRsp, err error)
	SayHelloReq(ctx context.Context, req *HelloRequest, opts ...http.CallOption) (rsp *HelloReply, err error)
}

type LudoHTTPClientImpl struct {
	cc *http.Client
}

func NewLudoHTTPClient(client *http.Client) LudoHTTPClient {
	return &LudoHTTPClientImpl{client}
}

func (c *LudoHTTPClientImpl) OnChatReq(ctx context.Context, in *ChatReq, opts ...http.CallOption) (*ChatRsp, error) {
	var out ChatRsp
	pattern := "/ludo/OnChatOrFaceReq"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationLudoOnChatReq))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *LudoHTTPClientImpl) OnDiceReq(ctx context.Context, in *DiceReq, opts ...http.CallOption) (*DiceRsp, error) {
	var out DiceRsp
	pattern := "/ludo/OnDiceReq"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationLudoOnDiceReq))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *LudoHTTPClientImpl) OnForwardReq(ctx context.Context, in *ForwardReq, opts ...http.CallOption) (*ForwardRsp, error) {
	var out ForwardRsp
	pattern := "/ludo/OnForwardReq"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationLudoOnForwardReq))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *LudoHTTPClientImpl) OnHostingReq(ctx context.Context, in *HostingReq, opts ...http.CallOption) (*HostingRsp, error) {
	var out HostingRsp
	pattern := "/ludo/OnHostingReq"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationLudoOnHostingReq))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *LudoHTTPClientImpl) OnLoginReq(ctx context.Context, in *LoginReq, opts ...http.CallOption) (*LoginRsp, error) {
	var out LoginRsp
	pattern := "/ludo/OnLoginReq"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationLudoOnLoginReq))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *LudoHTTPClientImpl) OnLogoutReq(ctx context.Context, in *LogoutReq, opts ...http.CallOption) (*LogoutRsp, error) {
	var out LogoutRsp
	pattern := "/ludo/OnLogoutReq"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationLudoOnLogoutReq))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *LudoHTTPClientImpl) OnMoveReq(ctx context.Context, in *MoveReq, opts ...http.CallOption) (*MoveRsp, error) {
	var out MoveRsp
	pattern := "/ludo/OnMoveReq"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationLudoOnMoveReq))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *LudoHTTPClientImpl) OnReadyReq(ctx context.Context, in *ReadyReq, opts ...http.CallOption) (*ReadyRsp, error) {
	var out ReadyRsp
	pattern := "/ludo/OnReadyReq"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationLudoOnReadyReq))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *LudoHTTPClientImpl) OnSceneReq(ctx context.Context, in *SceneReq, opts ...http.CallOption) (*SceneRsp, error) {
	var out SceneRsp
	pattern := "/ludo/OnSceneReq"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationLudoOnSceneReq))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *LudoHTTPClientImpl) OnSwitchTableReq(ctx context.Context, in *SwitchTableReq, opts ...http.CallOption) (*SwitchTableRsp, error) {
	var out SwitchTableRsp
	pattern := "/ludo/OnSwitchTableReq"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationLudoOnSwitchTableReq))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *LudoHTTPClientImpl) SayHelloReq(ctx context.Context, in *HelloRequest, opts ...http.CallOption) (*HelloReply, error) {
	var out HelloReply
	pattern := "/ludo/{name}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationLudoSayHelloReq))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}
