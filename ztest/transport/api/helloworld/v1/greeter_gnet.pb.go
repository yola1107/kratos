// Code generated by protoc-gen-go-gnet. DO NOT EDIT.
// versions:
// - protoc-gen-go-gnet v2.8.6
// - protoc             v3.6.1
// source: helloworld/v1/greeter.proto

package v1

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
import (
	"context"

	"github.com/yola1107/kratos/v2/library/work"
	"github.com/yola1107/kratos/v2/transport/gnet"

	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/proto"
)

// GreeterGNETServer is the server API for Greeter service.
type GreeterGNETServer interface {
	GetLoop() work.Loop
	// SayHelloReq Sends a greeting
	SayHelloReq(context.Context, *HelloRequest) (*HelloReply, error)
	// SayHello2ReqSends a greeting by post
	SayHello2Req(context.Context, *Hello2Request) (*Hello2Reply, error)
}

func RegisterGreeterGNETServer(s *gnet.Server, srv GreeterGNETServer) {
	s.RegisterService(&Greeter_GNET_ServiceDesc, srv)
}

func _Greeter_SayHelloReq_GNET_Handler(srv interface{}, ctx context.Context, data []byte, interceptor gnet.UnaryServerInterceptor) ([]byte, error) {
	in := new(HelloRequest)
	if err := proto.Unmarshal(data, in); err != nil {
		return nil, err
	}
	doFunc := func(ctx context.Context, req *HelloRequest) ([]byte, error) {
		doRequest := func() ([]byte, error) {
			resp, err := srv.(GreeterGNETServer).SayHelloReq(ctx, req)
			if err != nil || resp == nil {
				return nil, err
			}
			return proto.Marshal(resp)
		}
		if loop := srv.(GreeterGNETServer).GetLoop(); loop != nil {
			return loop.PostAndWaitCtx(ctx, doRequest)
		}
		return doRequest()
	}
	if interceptor == nil {
		return doFunc(ctx, in)
	}
	info := &gnet.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/helloworld.v1.Greeter/SayHelloReq",
	}
	interceptorHandler := func(ctx context.Context, req interface{}) ([]byte, error) {
		r, ok := req.(*HelloRequest)
		if !ok {
			return nil, status.Errorf(codes.InvalidArgument, "Invalid Request Argument, expect: *HelloRequest, Not: %T", req)
		}
		return doFunc(ctx, r)
	}
	return interceptor(ctx, in, info, interceptorHandler)
}

func _Greeter_SayHello2Req_GNET_Handler(srv interface{}, ctx context.Context, data []byte, interceptor gnet.UnaryServerInterceptor) ([]byte, error) {
	in := new(Hello2Request)
	if err := proto.Unmarshal(data, in); err != nil {
		return nil, err
	}
	doFunc := func(ctx context.Context, req *Hello2Request) ([]byte, error) {
		doRequest := func() ([]byte, error) {
			resp, err := srv.(GreeterGNETServer).SayHello2Req(ctx, req)
			if err != nil || resp == nil {
				return nil, err
			}
			return proto.Marshal(resp)
		}
		if loop := srv.(GreeterGNETServer).GetLoop(); loop != nil {
			return loop.PostAndWaitCtx(ctx, doRequest)
		}
		return doRequest()
	}
	if interceptor == nil {
		return doFunc(ctx, in)
	}
	info := &gnet.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/helloworld.v1.Greeter/SayHello2Req",
	}
	interceptorHandler := func(ctx context.Context, req interface{}) ([]byte, error) {
		r, ok := req.(*Hello2Request)
		if !ok {
			return nil, status.Errorf(codes.InvalidArgument, "Invalid Request Argument, expect: *Hello2Request, Not: %T", req)
		}
		return doFunc(ctx, r)
	}
	return interceptor(ctx, in, info, interceptorHandler)
}

var Greeter_GNET_ServiceDesc = gnet.ServiceDesc{
	ServiceName: "helloworld.v1.Greeter",
	HandlerType: (*GreeterGNETServer)(nil),
	Methods: []gnet.MethodDesc{
		{
			MethodName: "SayHelloReq",
			Handler:    _Greeter_SayHelloReq_GNET_Handler,
			Ops:        1001,
		},
		{
			MethodName: "SayHello2Req",
			Handler:    _Greeter_SayHello2Req_GNET_Handler,
			Ops:        1003,
		},
	},
}
