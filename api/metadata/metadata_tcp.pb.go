// Code generated by protoc-gen-go-tcp. DO NOT EDIT.
// versions:
// - protoc-gen-go-tcp v2.8.8
// - protoc            v3.6.1
// source: metadata/metadata.proto

package metadata

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
import (
	"context"

	"github.com/yola1107/kratos/v2/library/work"
	"github.com/yola1107/kratos/v2/transport/tcp"

	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/proto"
)

// MetadataTCPServer is the server API for Metadata service.
type MetadataTCPServer interface {
	GetLoop() work.Loop
	SetCometChan(cl *tcp.ChanList, cs *tcp.Server)
	ListServices(context.Context, *ListServicesRequest) (*ListServicesReply, error)
	GetServiceDesc(context.Context, *GetServiceDescRequest) (*GetServiceDescReply, error)
}

func RegisterMetadataTCPServer(s *tcp.Server, srv MetadataTCPServer) {
	chanList := s.RegisterService(&Metadata_TCP_ServiceDesc, srv)
	srv.SetCometChan(chanList, s)
}

func _Metadata_ListServices_TCP_Handler(srv interface{}, ctx context.Context, data []byte, interceptor tcp.UnaryServerInterceptor) ([]byte, error) {
	in := new(ListServicesRequest)
	if err := proto.Unmarshal(data, in); err != nil {
		return nil, err
	}
	handler := func(ctx context.Context, req *ListServicesRequest) ([]byte, error) {
		resp, err := srv.(MetadataTCPServer).ListServices(ctx, req)
		if err != nil {
			return nil, err
		}
		data, err := proto.Marshal(resp)
		if err != nil {
			return nil, err
		}
		if loop := srv.(MetadataTCPServer).GetLoop(); loop != nil {
			return loop.PostAndWaitCtx(ctx, func() ([]byte, error) { return data, nil })
		}
		return data, nil
	}
	if interceptor == nil {
		return handler(ctx, in)
	}
	info := &tcp.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kratos.api.Metadata/ListServices",
	}
	interceptorHandler := func(ctx context.Context, req interface{}) ([]byte, error) {
		r, ok := req.(*ListServicesRequest)
		if !ok {
			return nil, status.Errorf(codes.InvalidArgument, "Invalid Request Argument, expect: *ListServicesRequest, Not: %T", req)
		}
		return handler(ctx, r)
	}
	return interceptor(ctx, in, info, interceptorHandler)
}

func _Metadata_GetServiceDesc_TCP_Handler(srv interface{}, ctx context.Context, data []byte, interceptor tcp.UnaryServerInterceptor) ([]byte, error) {
	in := new(GetServiceDescRequest)
	if err := proto.Unmarshal(data, in); err != nil {
		return nil, err
	}
	handler := func(ctx context.Context, req *GetServiceDescRequest) ([]byte, error) {
		resp, err := srv.(MetadataTCPServer).GetServiceDesc(ctx, req)
		if err != nil {
			return nil, err
		}
		data, err := proto.Marshal(resp)
		if err != nil {
			return nil, err
		}
		if loop := srv.(MetadataTCPServer).GetLoop(); loop != nil {
			return loop.PostAndWaitCtx(ctx, func() ([]byte, error) { return data, nil })
		}
		return data, nil
	}
	if interceptor == nil {
		return handler(ctx, in)
	}
	info := &tcp.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kratos.api.Metadata/GetServiceDesc",
	}
	interceptorHandler := func(ctx context.Context, req interface{}) ([]byte, error) {
		r, ok := req.(*GetServiceDescRequest)
		if !ok {
			return nil, status.Errorf(codes.InvalidArgument, "Invalid Request Argument, expect: *GetServiceDescRequest, Not: %T", req)
		}
		return handler(ctx, r)
	}
	return interceptor(ctx, in, info, interceptorHandler)
}

var Metadata_TCP_ServiceDesc = tcp.ServiceDesc{
	ServiceName: "kratos.api.Metadata",
	HandlerType: (*MetadataTCPServer)(nil),
	Methods: []tcp.MethodDesc{
		{
			MethodName: "ListServices",
			Handler:    _Metadata_ListServices_TCP_Handler,
			Ops:        1001,
		},
		{
			MethodName: "GetServiceDesc",
			Handler:    _Metadata_GetServiceDesc_TCP_Handler,
			Ops:        1003,
		},
	},
}
